{
  "author": {
    "name": "Sergey Korotkov",
    "email": "sergeyksv@gmail.com"
  },
  "name": "safe",
  "version": "0.1.4",
  "repository": {
    "type": "git",
    "url": "git://github.com/sergeyksv/safejs.git"
  },
  "contributors": [],
  "main": "./lib/safe",
  "engines": {
    "node": ">= v0.4.x"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": ""
  },
  "scripts": {
    "test": "mocha -bR spec ./test/test.js"
  },
  "readme": "Module provides set of handy function to deal with thrown errors, callbacks and\nnodejs alike error passing (first function argument). It can be used standalone or as addon for [Async](https://github.com/caolan/async) library\n\nThe goal is to make code more stable, readable and avoid\nsome routine calls. Idea is inspired in [Step](https://github.com/creationix/step) library which catches thrown errors and convert them into callback function calls. \n\n[Async](https://github.com/caolan/async) library which appears more handy missing this. With safe library it is easy to plug-in this when required.\n\nFunction are kind of chainable, so instead of `safe.trap(safe.sure(function () {} ))`\nit is possible to use `safe.trap_sure(function() {})`\n\n[![Build Status](https://travis-ci.org/sergeyksv/safejs.png?branch=master)](https://travis-ci.org/sergeyksv/safejs)\n\n### Plain poor code:\n\tasync.series([\n\t\tfunction (callback) {\n\t\t\t// .. do something that can throw error\n\t\t\t// BAD: some dirty code can throw exception here\n\t\t\t// which breaks nodejs server\n\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\tsome.getSome(e.id, function (err, some) {\n\t\t\t\t\t// BAD: err is not checked \n\t\t\t\t\t// .. process some\n\t\t\t\t\t// BAD: boring code\n\t\t\t\t\tcallback2();\n\t\t\t\t})\n\t\t\t},callback)\n\t\t}]\n\n### Plain good code:\n\tasync.series([\n\t\tfunction (callback) {\n\t\t\ttry {\n\t\t\t\t// .. do something that can throw error\n\t\t\t\t// .. note ANY CODE CAN DO in some conditions\n\t\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\t\tsome.getSome(e.id, function (err, some) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (err) return callback2(err);\n\t\t\t\t\t\t\t// .. process some\n\t\t\t\t\t\t\tcallback2();\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tcallback2(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},callback)\n\t\t\t} catch (err) {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t}]\n\n###  Safe enhanced good code:\n\tasync.series([\n\t\tsafe.trap(function (callback) {\n\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\tsome.getSome(e.id, safe.trap_sure_results(callback2, function (some) {\n\t\t\t\t\t// .. process some\n\t\t\t\t});\n\t\t\t},callback)\n\t\t}\n\nWe also found that in some simple cases safe functions allows to write\ncode that does things similar to async.series or async.waterfall in bit \nmore efficient way (at least as we think). It became possible\nbecause JavaScript closures are in effect and you not need to think how\nto pass variables from one function to another. In theory async.waterfall should\nhelp for such case but it has two caveats. First is when one of funtions\nthat you used change number of paramaters returned thru callback. Code became\nbroken and error is hard to find. Second one is that if result of one step\nis required later then next step you have to pass it thru intermidiate\nsteps which makes waterfall behavior fall down to async.series. Check \nthis on examples\n\n#### Classic async.series\n\t\tvar users, user, clients;\n\t\tasync.series([\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"users\",function (err,val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tusers = val;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tusers.findOne({login:\"john\"},fuction (err, val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tsession.user = user;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"clients\",function (err,val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tclients = val;\n\t\t\t\t})\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t}\n\t\t], function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\n\t\t\n#### Classic async.waterfall\n\t\tasync.waterfall([\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"users\",callback)\n\t\t\t},\n\t\t\tfunction (users,callback) {\n\t\t\t\tusers.findOne({login:\"john\"},callback)\n\t\t\t},\n\t\t\tfunction (user,callback) {\n\t\t\t\tmongo.collection(\"clients\",function (err, clients) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null,user,clients)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction (user,clients,callback) {\n                                sesson.user = user;\n\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t}\n\t\t], function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\t\t\n\n#### Safe enhanced\n\t\tsafe.run(function(callback) {\n\t\t\tmongo.collection(\"users\",safe.sure(callback, function (users) {\n\t\t\t\tusers.findOne({login:\"john\"},safe.sure(callback, fuction (user) {\n\t\t\t\t\tsession.user = user;\n\t\t\t\t\tmongo.collection(\"clients\",safe.sure(callback, function (clients) {\n\t\t\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t\t\t}))\n\t\t\t\t}))\n\t\t\t}))\n\t\t}, function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\n\n\n### API\n\n#### result\nTransform synchronious function call result to callback\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n\n@param {Function} fn wrapped function\n\n\n#### sure\nStrip (hide) first parameter from wrapped function and ensure that\ncontroll is passed to it when no error happpens. I.e. it does do\nroutine error check `if (err) return callback(err)`\n\nIf passed non function it just returned thru callback\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n\n@param {Function} wrapped function or value\n\n#### trap\nWrap function call into try catch, pass thrown error to callback\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n\n@param {Function} fn wrapped function\n\n#### run\nRun function with provided callback. Just help to have better readability.\nUsefull when you need to handle local callback results, even if there are\nerrors. \n\n@param {Function} wrapped function\n\n@param {Function} callback\n\n#### yield\nYields execution of function giving chance to other stuff run\n\n@param {Function} callback\n\n#### noop\nEmpty function, does nothing. Sometime useful.\n\n#### back\nRun provided callback in next tick of event loop. This is what for\nprocess.nextTick was usually used. However for very strange reason\nstarting from node v10 it fails when called recursively. \n\nTo be honest its failry stupid because now process.nextTick became\nuseless because will it work or not depends on callee. It was honest\njust to say to stop use process.nextTick, there is no any purpose for\nit any longer. Function safe.run will use process.nextTick or its new successor\nsetImmediate in newer versions of node.\n\nAnyway process.nextTick usually was used to break recursion or to maintain async\nbehavior when function return something right away without calling\ntrully async function (IO mostly). It was required to write something\nlike:\n\n\tif (cached)\n\t\treturn process.nextTick(function () {callback(null,cached})\nwith back:\n\n\tif (cached)\n\t\treturn safe.back(callback,null,cached) \n\n@param {Function} callback\n\n@param argument1\n\n@param argumentN\n\n#### spread\nWraps function with several parameters into function that accept array of paramters. Useful to process async.series or async.parallel result calls.\n\n@param {Function} - normal function \n\nNormal async code:\n\n\t], function (err, res) {\n\t\tif (err) return callback(err)\n\t\tvar me = res[0];\n\t\tvar users = res[1];\n\nUsing safe:\n\n\t],safe.sure_spread(callback, function (me, users) {\n\n#### async\nComplimentary helper function to \"async\" libray similar to async.apply. The difference is that it bind function call to some specific object context.\n\n@param {Object} - context object\n\n@param {String} - function name\n\n@param ... - function arguments\n\nNormal async code:\n\n\tasync.series([\n\t\tfunction (cb) {\n\t\t\tusers.findOne({gender:\"male\"},cb)\n\t\t}\n\nUsing safe:\n\t\t\n\tasync.series([\n\t\tsafe.async(users,\"findOne\",{gender:\"male\"})\n\n#### wrap\nSimilar to _trap_ but has reverse order of parameters. Both paramters are required. Callback will be appended to wrapped function as last parameter. Useful to simulate try catch behavior for functions that didn't receive callback but still need error handling\n\n@param {Function} fn wrapped function\n\n@param {Function} callback or wrapped function\n\n#### pseudo chains\n\nsure_result, sure_spread\n\ntrap_sure, trap_sure_result - __deprecated__ Since version 0.1.x all functions catch thrown exceprtions\n",
  "readmeFilename": "README.md",
  "description": "Module provides set of handy function to deal with thrown errors, callbacks and nodejs alike error passing (first function argument). It can be used standalone or as addon for [Async](https://github.com/caolan/async) library",
  "bugs": {
    "url": "https://github.com/sergeyksv/safejs/issues"
  },
  "_id": "safe@0.1.4",
  "_from": "safe@>=0.1.2"
}
